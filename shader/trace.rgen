#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable

#include "denoisecommon.glsl"
#include "raycommon.glsl"
#include "scene.glsl"

layout(location = 0) rayPayloadEXT HitPayload rPayload;

layout(binding = 0, set = 0) uniform accelerationStructureEXT TLAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D colorImage;              // W
layout(binding = 6, set = 0, rgba32f) uniform image2D illuminationImage;       // W
layout(binding = 7, set = 0, rgba32f) uniform image2D prevIlluminationImage;   // R
layout(binding = 8, set = 0, rgba32f) uniform image2D normalsImage;            // W
layout(binding = 9, set = 0, rgba32f) uniform image2D prevDepthImage;          // R

layout(binding = 2, set = 0, scalar) uniform _SceneUniform { SceneUniform uSceneObject; };

vec2 reproject(vec3 worldPosition, mat4 view, mat4 projection) {
	vec4 clipSpace = projection * view * vec4(worldPosition, 1.0);
	vec2 ndc = clipSpace.xy / clipSpace.w;
	return (ndc + 1.0) / 2.0;
}

bool inRange(ivec2 uv, ivec2 minv, ivec2 maxv) {
	return all(greaterThanEqual(uv, minv)) && all(lessThanEqual(uv, maxv));
}

vec4 getDepthDiffAndNormal(ivec2 prevPixelCoord, HitPayload primaryPayload) {

	vec4 prevDepthAndNormals = imageLoad(prevDepthImage, prevPixelCoord);
	float prevDepth = prevDepthAndNormals.a;

	vec2 ndcXY = vec2(prevPixelCoord) / gl_LaunchSizeEXT.xy * 2.0 - 1.0;
	vec4 clipPos = vec4(ndcXY, prevDepth, 1.0);

	vec4 viewPos = inverse(uSceneObject.prevProjection) * clipPos;
	viewPos /= viewPos.w;

	vec4 worldPos4 = inverse(uSceneObject.prevView) * viewPos;
	vec3 prevWorldPos = worldPos4.xyz;

	vec3 currWorldPos = primaryPayload.hit.xyz;

	float worldPosDiff = distance(prevWorldPos, currWorldPos);

	return vec4(prevDepthAndNormals.xyz, worldPosDiff);
}

vec4 samplePrevIllumination(vec2 uv, HitPayload primaryPayload) {

	const float DEPTH_THRESHOLD = 0.2;
	const float NORMAL_THRESHOLD = 0.5;

	ivec2 texSize = imageSize(prevIlluminationImage);

	vec2 pos = uv * vec2(texSize) - 0.5;

	ivec2 pos0 = ivec2(floor(pos));
	vec2 frac = pos - floor(pos);

	ivec2 pos1 = pos0 + ivec2(1, 0);
	ivec2 pos2 = pos0 + ivec2(0, 1);
	ivec2 pos3 = pos0 + ivec2(1, 1);

	vec4 depthNormal0 = getDepthDiffAndNormal(pos0, primaryPayload);
	vec4 depthNormal1 = getDepthDiffAndNormal(pos1, primaryPayload);
	vec4 depthNormal2 = getDepthDiffAndNormal(pos2, primaryPayload);
	vec4 depthNormal3 = getDepthDiffAndNormal(pos3, primaryPayload);

	bool range0 = inRange(pos0, ivec2(0), texSize - ivec2(1)) && depthNormal0.w < DEPTH_THRESHOLD 
		&& normalEdgeStoppingWeight(primaryPayload.normal.xyz, depthNormal0.xyz, 128.0) > NORMAL_THRESHOLD;

	bool range1 = inRange(pos1, ivec2(0), texSize - ivec2(1)) && depthNormal1.w < DEPTH_THRESHOLD 
		&& normalEdgeStoppingWeight(primaryPayload.normal.xyz, depthNormal1.xyz, 128.0) > NORMAL_THRESHOLD;

	bool range2 = inRange(pos2, ivec2(0), texSize - ivec2(1)) && depthNormal2.w < DEPTH_THRESHOLD
		&& normalEdgeStoppingWeight(primaryPayload.normal.xyz, depthNormal2.xyz, 128.0) > NORMAL_THRESHOLD;

	bool range3 = inRange(pos3, ivec2(0), texSize - ivec2(1)) && depthNormal3.w < DEPTH_THRESHOLD
		&& normalEdgeStoppingWeight(primaryPayload.normal.xyz, depthNormal3.xyz, 128.0) > NORMAL_THRESHOLD;

	vec4 tex0 = range0 ? imageLoad(prevIlluminationImage, pos0) : vec4(0.0);
	vec4 tex1 = range1 ? imageLoad(prevIlluminationImage, pos1) : vec4(0.0);
	vec4 tex2 = range2 ? imageLoad(prevIlluminationImage, pos2) : vec4(0.0);
	vec4 tex3 = range3 ? imageLoad(prevIlluminationImage, pos3) : vec4(0.0);

	tex0 = range0 ? tex0 : tex1;
	tex1 = range1 ? tex1 : tex0;

	tex2 = range2 ? tex2 : tex3;
	tex3 = range3 ? tex3 : tex2;

	vec4 interpX0 = mix(tex0, tex1, frac.x);
	vec4 interpX1 = mix(tex2, tex3, frac.x);

	bool range01 = range0 || range1;
	bool range23 = range2 || range3;

	interpX0 = range01 ? interpX0 : interpX1;
	interpX1 = range23 ? interpX1 : interpX0;

	if (!range01 && !range23) {
		return vec4(0.0);
	}

	return mix(interpX0, interpX1, frac.y);
}

void main() {
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	mat4 viewInverse = inverse(uSceneObject.view);
	mat4 projInverse = inverse(uSceneObject.projection);
	
	/**
	 * Primary ray
	 */

	vec4 origin = viewInverse * vec4(0, 0, 0, 1);
	vec4 target = projInverse * vec4(d.x, d.y, 1, 1);
	vec4 direction = viewInverse * vec4(normalize(target.xyz), 0);

	float tMin = uSceneObject.near;
	float tMax = uSceneObject.far;
	uint primaryRayFlags = gl_RayFlagsOpaqueEXT;

	int jump = 0;
	// The primary ray is also considered a jump
	const int MAX_JUMPS = 2;

	// firstPrimary is an actual primary ray payload, while primaryPayload is a primary ray that went through the portal
	HitPayload firstPrimary;

	while (jump < MAX_JUMPS) {
		jump++;

		traceRayEXT(TLAS,          // acceleration structure
			primaryRayFlags,       // rayFlags
			0xFF,                  // cullMask
			0,                     // sbtRecordOffset
			0,                     // sbtRecordStride
			0,                     // missIndex
			origin.xyz,            // ray origin
			tMin,                  // ray min range
			direction.xyz,         // ray direction
			tMax,                  // ray max range
			0                      // payload location
		);

		if (jump == 1) {
			firstPrimary = rPayload;
		}

		if (rPayload.hit.w == 0 || rPayload.portal[0][0] == 0 || jump == MAX_JUMPS) {
			break;
		}

		// Apply portal transformation
		origin = rPayload.portal * vec4(rPayload.hit.xyz, 1);
		direction = normalize(rPayload.portal * vec4(rPayload.hit.xyz + direction.xyz, 1) - origin);
	}

	HitPayload primaryPayload = rPayload;

	vec3 portalTint = vec3(0.1) * (jump - 1);
	vec3 outColor = primaryPayload.color.xyz + portalTint;

	float depthValue = tMax;

	if (firstPrimary.hit.w > 0) {
		vec4 hitView = uSceneObject.view * vec4(firstPrimary.hit.xyz, 1.0);
		vec4 hitClip = uSceneObject.projection * hitView;
		depthValue = hitClip.z / hitClip.w;
	}

	/**
	 * Global illumination and reflections
	 */

	if (primaryPayload.hit.w > 0){

		const int samples = 1;

		vec3 giLight = vec3(0.0);
		float seed = gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * 3.43121412313 + fract(1.12345314312 * uSceneObject.time);

		for (int i = 0; i < samples; i++) {

			vec3 reflectionDirection = reflect(direction.xyz, primaryPayload.normal.xyz);		
			vec3 diffuseDirection = cosWeightedRandomHemisphereDirection(primaryPayload.normal.xyz, seed);

			bool isSpecular = hash1(seed) < primaryPayload.specular.x;
			vec3 secondaryDirection = normalize(mix(diffuseDirection, reflectionDirection, float(isSpecular) * (primaryPayload.specular.w / 1000.0)));
		
			vec3 secondaryOrigin = primaryPayload.hit.xyz + primaryPayload.normal.xyz * 0.001;

			traceRayEXT(TLAS,          // acceleration structure
				primaryRayFlags,       // rayFlags
				0xFF,                  // cullMask
				0,                     // sbtRecordOffset
				0,                     // sbtRecordStride
				0,                     // missIndex
				secondaryOrigin,       // ray origin
				0.001,                 // ray min range
				secondaryDirection,    // ray direction
				tMax,                  // ray max range
				0                      // payload location
			);

			giLight += rPayload.light.xyz * rPayload.color.xyz * 2.0;
		}

		vec2 prevPixelCoord = reproject(firstPrimary.hit.xyz, uSceneObject.prevView, uSceneObject.prevProjection);

		vec4 prevFrameLight = vec4(0.0);
		float sampleAge = 0.0;

		if (prevPixelCoord.x >= 0 && prevPixelCoord.x < 1 && prevPixelCoord.y >= 0 && prevPixelCoord.y < 1) {

			// While reprojecting image from the portal, use primary ray's hit position,
			// and a normal from a ray that went through the portal
			HitPayload reprojectionPayload = firstPrimary;
			reprojectionPayload.normal = primaryPayload.normal;

			prevFrameLight = samplePrevIllumination(prevPixelCoord, reprojectionPayload);
			sampleAge = floor(prevFrameLight.a);
		}

		vec3 currentLight = primaryPayload.light.rgb + (giLight / float(samples));
		
		vec3 mixedLight = mix(prevFrameLight.rgb, currentLight, 1.0 / (sampleAge + 1.0));
		sampleAge = min(sampleAge + 1.0, 200.0);

		imageStore(illuminationImage, ivec2(gl_LaunchIDEXT.xy), vec4(mixedLight, sampleAge));
		imageStore(normalsImage, ivec2(gl_LaunchIDEXT.xy), vec4(primaryPayload.normal.xyz, depthValue));
	}
	else {
		imageStore(illuminationImage, ivec2(gl_LaunchIDEXT.xy), vec4(1.0));
		imageStore(normalsImage, ivec2(gl_LaunchIDEXT.xy), vec4(0.0));
	}

	/**
	 * Write to the output image
	 */	

	imageStore(colorImage, ivec2(gl_LaunchIDEXT.xy), vec4(outColor, depthValue));
}
