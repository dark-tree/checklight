#version 460
#extension GL_EXT_ray_tracing : require

struct HitPayload {
	// posX, posY, posZ, hit
	vec4 hit;
	// colorR, colorG, colorB
	vec4 color;
	// lightR, lightG, lightB
	vec4 light;
	// normalX, normalY, normalZ
	vec4 normal;
	// specularR, specularG, specularB, shininess
	vec4 specular;
};

layout(location = 0) rayPayloadEXT HitPayload rPayload;

layout(binding = 0, set = 0) uniform accelerationStructureEXT TLAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;

layout(binding = 2, set = 0) uniform SceneUniform {
	mat4 view;
	mat4 projection;
} uSceneObject;

float hash1(inout float seed) {
	return fract(sin(seed += 0.1) * 43758.5453123);
}

vec2 hash2(inout float seed) {
	return fract(sin(vec2(seed += 0.1, seed += 0.1)) * vec2(43758.5453123, 22578.1459123));
}

vec3 hash3(inout float seed) {
	return fract(sin(vec3(seed += 0.1, seed += 0.1, seed += 0.1)) * vec3(43758.5453123, 22578.1459123, 19642.3490423));
}

vec3 cosWeightedRandomHemisphereDirection(const vec3 n, inout float seed) {
	vec2 r = hash2(seed);

	vec3  uu = normalize(cross(n, vec3(0.0, 1.0, 1.0)));
	vec3  vv = cross(uu, n);

	float ra = sqrt(r.y);
	float rx = ra * cos(6.2831 * r.x);
	float ry = ra * sin(6.2831 * r.x);
	float rz = sqrt(1.0 - r.y);
	vec3  rr = vec3(rx * uu + ry * vv + rz * n);

	return normalize(rr);
}

vec3 randomSphereDirection(inout float seed) {
	vec2 h = hash2(seed) * vec2(2., 6.28318530718) - vec2(1, 0);
	float phi = h.y;
	return vec3(sqrt(1. - h.x * h.x) * vec2(sin(phi), cos(phi)), h.x);
}

void main() {
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	mat4 viewInverse = inverse(uSceneObject.view);
	mat4 projInverse = inverse(uSceneObject.projection);
	
	/**
	 * Primary ray
	 */

	vec4 origin = viewInverse * vec4(0, 0, 0, 1);
	vec4 target = projInverse * vec4(d.x, d.y, 1, 1);
	vec4 direction = viewInverse * vec4(normalize(target.xyz), 0);

	float tMin = 0.001;
	float tMax = 10000.0;
	uint primaryRayFlags = gl_RayFlagsOpaqueEXT;

	traceRayEXT(TLAS,          // acceleration structure
		primaryRayFlags,       // rayFlags
		0xFF,                  // cullMask
		0,                     // sbtRecordOffset
		0,                     // sbtRecordStride
		0,                     // missIndex
		origin.xyz,            // ray origin
		tMin,                  // ray min range
		direction.xyz,         // ray direction
		tMax,                  // ray max range
		0                      // payload location
	);

	HitPayload primaryPayload = rPayload;

	vec3 outColor = primaryPayload.color.xyz;

	float depthValue = tMax;
	if (primaryPayload.hit.w > 0) {
		depthValue = length(primaryPayload.hit.xyz - origin.xyz);
	}

	/**
	 * Global illumination and reflections
	 */

	if (primaryPayload.hit.w > 0){
		const int samples = 2;

		vec3 giColor = vec3(0.0);
		float seed = gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * 3.43121412313 + fract(1.12345314312);

		for (int i = 0; i < samples; i++) {

			vec3 reflectionDirection = reflect(direction.xyz, primaryPayload.normal.xyz);		
			vec3 diffuseDirection = cosWeightedRandomHemisphereDirection(primaryPayload.normal.xyz, seed);

			bool isSpecular = hash1(seed) < primaryPayload.specular.x;
			vec3 secondaryDirection = normalize(mix(diffuseDirection, reflectionDirection, float(isSpecular) * (primaryPayload.specular.w / 1000.0)));
		
			origin.xyz = primaryPayload.hit.xyz + primaryPayload.normal.xyz * 0.001;

			traceRayEXT(TLAS,          // acceleration structure
				primaryRayFlags,       // rayFlags
				0xFF,                  // cullMask
				0,                     // sbtRecordOffset
				0,                     // sbtRecordStride
				0,                     // missIndex
				origin.xyz,            // ray origin
				tMin,                  // ray min range
				secondaryDirection,    // ray direction
				tMax,                  // ray max range
				0                      // payload location
			);

			giColor += rPayload.light.xyz * rPayload.color.xyz;
		}

		outColor = primaryPayload.color.rgb * (primaryPayload.light.rgb + (giColor / float(samples)));
	}

	/**
	 * Write to the output image
	 */

	float delinearized = ((1.0 / depthValue) - 1 / tMin) / ((1 / tMax) - (1 / tMin));
	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(outColor, delinearized));
}
