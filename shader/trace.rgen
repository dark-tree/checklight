#version 460
#extension GL_EXT_ray_tracing : require

struct HitPayload {
	// posX, posY, posZ, hit
	vec4 hit;
	// colorR, colorG, colorB
	vec4 color;
	// lightR, lightG, lightB
	vec4 light;
	// normalX, normalY, normalZ
	vec4 normal;
	// specularR, specularG, specularB, shininess
	vec4 specular;
};

layout(location = 0) rayPayloadEXT HitPayload rPayload;

layout(binding = 0, set = 0) uniform accelerationStructureEXT TLAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D colorImage;
layout(binding = 6, set = 0, rgba32f) uniform image2D illuminationImage;
layout(binding = 7, set = 0, rgba32f) uniform image2D prevIlluminationImage;
layout(binding = 8, set = 0, rgba32f) uniform image2D normalsImage;

layout(binding = 2, set = 0) uniform SceneUniform {
	mat4 view;
	mat4 projection;
	mat4 prevView;
	mat4 prevProjection;
	float time;
} uSceneObject;

float hash1(inout float seed) {
	return fract(sin(seed += 0.1) * 43758.5453123);
}

vec2 hash2(inout float seed) {
	return fract(sin(vec2(seed += 0.1, seed += 0.1)) * vec2(43758.5453123, 22578.1459123));
}

vec3 hash3(inout float seed) {
	return fract(sin(vec3(seed += 0.1, seed += 0.1, seed += 0.1)) * vec3(43758.5453123, 22578.1459123, 19642.3490423));
}

vec3 cosWeightedRandomHemisphereDirection(const vec3 n, inout float seed) {
	vec2 r = hash2(seed);

	vec3  uu = normalize(cross(n, vec3(0.0, 1.0, 1.0)));
	vec3  vv = cross(uu, n);

	float ra = sqrt(r.y);
	float rx = ra * cos(6.2831 * r.x);
	float ry = ra * sin(6.2831 * r.x);
	float rz = sqrt(1.0 - r.y);
	vec3  rr = vec3(rx * uu + ry * vv + rz * n);

	return normalize(rr);
}

vec3 randomSphereDirection(inout float seed) {
	vec2 h = hash2(seed) * vec2(2., 6.28318530718) - vec2(1, 0);
	float phi = h.y;
	return vec3(sqrt(1. - h.x * h.x) * vec2(sin(phi), cos(phi)), h.x);
}

vec2 reproject(vec3 worldPosition, mat4 view, mat4 projection) {
	vec4 clipSpace = projection * view * vec4(worldPosition, 1.0);
	vec2 ndc = clipSpace.xy / clipSpace.w;
	return (ndc + 1.0) / 2.0;
}

bool inRange(ivec2 uv, ivec2 minv, ivec2 maxv) {
	return all(greaterThanEqual(uv, minv)) && all(lessThanEqual(uv, maxv));
}

vec4 samplePrevIllumination(vec2 uv) {

    ivec2 texSize = imageSize(prevIlluminationImage);

    vec2 pos = uv * vec2(texSize) - 0.5;

    ivec2 pos0 = ivec2(floor(pos));
    vec2 frac = pos - floor(pos);

    ivec2 pos1 = pos0 + ivec2(1, 0);
    ivec2 pos2 = pos0 + ivec2(0, 1);
    ivec2 pos3 = pos0 + ivec2(1, 1);

    vec4 tex0 = inRange(pos0, ivec2(0), texSize - ivec2(1)) ? imageLoad(prevIlluminationImage, pos0) : vec4(0.0);
	vec4 tex1 = inRange(pos1, ivec2(0), texSize - ivec2(1)) ? imageLoad(prevIlluminationImage, pos1) : vec4(0.0);
	vec4 tex2 = inRange(pos2, ivec2(0), texSize - ivec2(1)) ? imageLoad(prevIlluminationImage, pos2) : vec4(0.0);
	vec4 tex3 = inRange(pos3, ivec2(0), texSize - ivec2(1)) ? imageLoad(prevIlluminationImage, pos3) : vec4(0.0);

    vec4 interpX0 = mix(tex0, tex1, frac.x);
    vec4 interpX1 = mix(tex2, tex3, frac.x);

    return mix(interpX0, interpX1, frac.y);
}

void main() {
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	mat4 viewInverse = inverse(uSceneObject.view);
	mat4 projInverse = inverse(uSceneObject.projection);
	
	/**
	 * Primary ray
	 */

	const vec4 origin = viewInverse * vec4(0, 0, 0, 1);
	const vec4 target = projInverse * vec4(d.x, d.y, 1, 1);
	const vec4 direction = viewInverse * vec4(normalize(target.xyz), 0);

	float tMin = 0.001;
	float tMax = 10000.0;
	uint primaryRayFlags = gl_RayFlagsOpaqueEXT;

	traceRayEXT(TLAS,          // acceleration structure
		primaryRayFlags,       // rayFlags
		0xFF,                  // cullMask
		0,                     // sbtRecordOffset
		0,                     // sbtRecordStride
		0,                     // missIndex
		origin.xyz,            // ray origin
		tMin,                  // ray min range
		direction.xyz,         // ray direction
		tMax,                  // ray max range
		0                      // payload location
	);

	HitPayload primaryPayload = rPayload;

	vec3 outColor = primaryPayload.color.xyz;

	float depthValue = tMax;

	if (primaryPayload.hit.w > 0) {
		vec4 hitView = uSceneObject.view * vec4(primaryPayload.hit.xyz, 1.0);  
		vec4 hitClip = uSceneObject.projection * hitView;   
		depthValue = hitClip.z / hitClip.w;    
	}

	/**
	 * Global illumination and reflections
	 */

	if (primaryPayload.hit.w > 0){
		const int samples = 1;

		vec3 giLight = vec3(0.0);
		float seed = gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * 3.43121412313 + fract(1.12345314312 * uSceneObject.time);

		for (int i = 0; i < samples; i++) {

			vec3 reflectionDirection = reflect(direction.xyz, primaryPayload.normal.xyz);		
			vec3 diffuseDirection = cosWeightedRandomHemisphereDirection(primaryPayload.normal.xyz, seed);

			bool isSpecular = hash1(seed) < primaryPayload.specular.x;
			vec3 secondaryDirection = normalize(mix(diffuseDirection, reflectionDirection, float(isSpecular) * (primaryPayload.specular.w / 1000.0)));
		
			vec3 secondaryOrigin = primaryPayload.hit.xyz + primaryPayload.normal.xyz * 0.001;

			traceRayEXT(TLAS,          // acceleration structure
				primaryRayFlags,       // rayFlags
				0xFF,                  // cullMask
				0,                     // sbtRecordOffset
				0,                     // sbtRecordStride
				0,                     // missIndex
				secondaryOrigin,       // ray origin
				tMin,                  // ray min range
				secondaryDirection,    // ray direction
				tMax,                  // ray max range
				0                      // payload location
			);

			giLight += rPayload.light.xyz * rPayload.color.xyz * 2.0;
		}

		vec2 prevPixelCoord = reproject(primaryPayload.hit.xyz, uSceneObject.prevView, uSceneObject.prevProjection);

		vec4 prevFrameLight = vec4(0.0);
		float sampleAge = 0.0;

		if (prevPixelCoord.x >= 0 && prevPixelCoord.x < 1 && prevPixelCoord.y >= 0 && prevPixelCoord.y < 1) {
			// TODO: Create separate image for reading 
			// (the same image is being written to in this shader, which can cause artifacts)
			float prevDepth = imageLoad(colorImage, ivec2(prevPixelCoord * gl_LaunchSizeEXT.xy)).a;

			vec2 ndcXY = prevPixelCoord * 2.0 - 1.0;
			vec4 clipPos = vec4(ndcXY, prevDepth, 1.0);

			vec4 viewPos = inverse(uSceneObject.prevProjection) * clipPos;
			viewPos /= viewPos.w;

			vec4 worldPos4 = inverse(uSceneObject.prevView) * viewPos;
			vec3 prevWorldPos = worldPos4.xyz;

			vec3 currWorldPos = primaryPayload.hit.xyz;

			float worldPosDiff = distance(prevWorldPos, currWorldPos);

			if (worldPosDiff < 0.2) {
				prevFrameLight = samplePrevIllumination(prevPixelCoord);
				//prevFrameLight = imageLoad(prevIlluminationImage, ivec2(prevPixelCoord * gl_LaunchSizeEXT.xy));
				sampleAge = floor(prevFrameLight.a);
			}
		}

		vec3 currentLight = primaryPayload.light.rgb + (giLight / float(samples));
		
		vec3 mixedLight = mix(prevFrameLight.rgb, currentLight, 1.0 / (sampleAge + 1.0));
		sampleAge += 1.0;

		imageStore(illuminationImage, ivec2(gl_LaunchIDEXT.xy), vec4(mixedLight, sampleAge));

		float worldDepth = distance(primaryPayload.hit.xyz, origin.xyz) / tMax;
		imageStore(normalsImage, ivec2(gl_LaunchIDEXT.xy), vec4(primaryPayload.normal.xyz, worldDepth));

		outColor = primaryPayload.color.rgb;
	}

	/**
	 * Write to the output image
	 */	

	imageStore(colorImage, ivec2(gl_LaunchIDEXT.xy), vec4(outColor, depthValue));
}
